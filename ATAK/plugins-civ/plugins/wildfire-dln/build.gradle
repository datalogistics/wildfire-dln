////////////////////////////////////////////////////////////////////////////////
//
// PLUGIN_VERSION is the common version name when describing the plugin.
// ATAK_VERSION   is for the version of ATAK this plugin should be compatible
//                with some examples include 3.11.0, 3.11.0.civ 3.11.1.fvey
//
////////////////////////////////////////////////////////////////////////////////

def PLUGIN_VERSION = "1.0";
def ATAK_VERSION = "4.0.0.CIV";


 buildscript {
    repositories {
        jcenter()
        google()
        mavenCentral()
        maven {
            url "https://jitpack.io"
        }

    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.2'
        classpath 'com.android.volley:volley:1.1.0'
        classpath 'org.apache.commons:commons-io:1.3.2'
    }
 }

allprojects {
    repositories {
        google() 
        mavenCentral()
        maven {
            url "https://jitpack.io"
        }
        jcenter()

    }
}

apply plugin: 'com.android.application'
apply plugin: 'idea'

dependencies {

    if (new File("$project.projectDir/../../ATAK/build/libs/main.jar").exists()) { 
        println("using the autobuilder version of main.jar");
        compileOnly fileTree(dir: '../../ATAK/build/libs', include: '*.jar')
    } else if (new File("$project.projectDir/../../main.jar").exists()) { 
        println("using the sdk version of main.jar");
       compileOnly fileTree(dir: '../..', include: '*.jar')
    } else if (new File("sdk/main.jar").exists()) {
        println("using the local version of main.jar");
        compileOnly fileTree(dir: 'sdk/main.jar', include: '*.jar')
    } else { 
        def props = new Properties()
        props.load(project.rootProject.file("local.properties").newDataInputStream())
        def sdkdir = props.getProperty("sdk.path").toString()
        if (sdkdir == null) { 
            println("error reading sdk.path from the local.properties file, this should point to the main.jar file");
        }
        if (new File(sdkdir).exists()) {
           println("using the local version of ${sdkdir}");
           compileOnly fileTree(dir: "${sdkdir}", include: '*.jar')
        }
    }


    implementation fileTree(dir: 'libs', include: '*.jar')
    implementation 'com.android.support:recyclerview-v7:22.0.0'
    implementation 'com.android.volley:volley:1.1.0'
    implementation 'org.apache.commons:commons-io:1.3.2'
}

// Attempt to get a suitable version name for the plugin based on
// either a git or svn repository
def getVersionName() { 
    try {
        def gitFile = new File("$project.projectDir/.git")
        if (gitFile.exists()) {
            def stdout = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'rev-parse', '--short', 'HEAD'
                standardOutput = stdout
            }
            def describe = stdout.toString().trim()
            println("versionName[git]: $describe")
            return describe
        } else { 
            def describe = getVersionCode()
            println("versionName[svn]: $describe")
            return describe
        }
    } catch (Exception e) {
       println("error occured, using revision of 1");
       return 1;
    }
}


// Attempt to get a suitable version code for the plugin based on
// either a git or svn repository
def getVersionCode() {
    try {
        def gitFile = new File("$project.projectDir/.git")
        new ByteArrayOutputStream().withStream { os ->
            if (gitFile.exists()) {
                def result = exec {
                    executable = 'git'
                    args = ['show', '-s', '--format=%ct']
                    standardOutput = os
                    ignoreExitValue = true
                }
             } else {
                def result = exec {
                    executable = 'svn'
                    args = ['info']
                    standardOutput = os
                    ignoreExitValue = true
                }
            }
            def outputAsString = os.toString()
            if (gitFile.exists()) {
                ext.revision = "$outputAsString".toInteger()
            } else {     
                def matchLastChangedRev = outputAsString =~ /Revision: (\d+)/
                def length = matchLastChangedRev.size()
                if (length > 0)
                   ext.revision = "${matchLastChangedRev[0][1]}".toInteger()
                else
                    ext.revision = 1
            }

            if (gitFile.exists())
                 println("version[git]: $revision");
            else
                 println("version[svn]: $revision");
        }
    } catch (Exception e) {
       println("error occured, using revision of 1");
       ext.revision = 1;
    }

    return revision
}

android {
    compileSdkVersion 21
    buildToolsVersion "28.0.3"

   dexOptions {
        jumboMode = true
    }

    lintOptions {
          checkReleaseBuilds true
          // Or, if you prefer, you can continue to check for errors in release builds,
          // but continue the build even when errors are found:
          abortOnError false
      }


    signingConfigs {
        debug {
            storeFile file("../../android_keystore")
            storePassword "tnttnt"
            keyAlias "wintec_mapping"
            keyPassword "tnttnt"
        }

        release {
            storeFile file("../../android_keystore")
            storePassword "tnttnt"
            keyAlias "wintec_mapping"
            keyPassword "tnttnt"
        }
    }


    buildTypes {
        debug {
            debuggable true
            manifestPlaceholders = [atakApiVersion: "com.atakmap.app@" + ATAK_VERSION ];
        }

        release {
            manifestPlaceholders = [atakApiVersion: "com.atakmap.app@" + ATAK_VERSION ];
            def f = new File("$project.projectDir/../../ATAK/build/outputs/mapping/release/mapping.txt");
            if (f.exists()) {
                System.setProperty("atak.proguard.mapping", "../../ATAK/build/outputs/mapping/release/mapping.txt")
            } else {
                println("no mapping file exists");
                file("$project.projectDir/build").mkdir()
                file("$project.projectDir/build/blank-mapping.txt").text="";
                System.setProperty("atak.proguard.mapping", "./build/blank-mapping.txt")
            }

            minifyEnabled true
            proguardFile 'proguard-gradle.txt'
            signingConfig signingConfigs.release
        }
    }

    packagingOptions {
        exclude 'META-INF/INDEX.LIST'
    }

    sourceSets {
        main {
            setProperty("archivesBaseName", "ATAK-Plugin-" + project.name + "-" + ATAK_VERSION + "-" + getVersionName())
            defaultConfig.versionCode = getVersionCode()
            defaultConfig.versionName = PLUGIN_VERSION + " (" + getVersionName() + ") - [" + ATAK_VERSION + "]"
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
            jniLibs.srcDirs = ['libs']


        }

        // Move the tests to tests/java, tests/res, etc...
        //instrumentTest.setRoot('tests')

        // Move the build types to build-types/<type>
        // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...
        // This moves them out of them default location under src/<type>/... which would
        // conflict with src/ being used by the main source set.
        // Adding new build types or product flavors should be accompanied
        // by a similar customization.
        debug.setRoot('build-types/debug')
        release.setRoot('build-types/release')

    }

    defaultConfig {
        minSdkVersion 21
        ndk {
            abiFilters "armeabi-v7a", "x86"
        }
    }


}
